"""Module contains methods and objects used for locally caching information related to bot functions."""

import asyncio
import json
from typing import Optional
import discord
from discord.ext import tasks, commands
import EduBotExceptions

class Cache():
    def __init__(self, bot: Optional[commands.Bot] = None):
        # reference to bot
        self.bot = bot
        
        #### DICTIONARIES ####
        # prefixCache dictionary stores the character used as a command prefix for each server the bot is a on
        self.prefixCache = {}

        # groupRolesCache dictionary stores sets of IDs of roles generated by the bot "group create" command
        # as values with guild IDs as keys
        self.groupRolesCache = {}

        # privilegedRolesCache dictionary stores sets of IDs of roles that are allowed to execute administrative
        # bot commands (i.e. group, kick, or role assignment commands) as values, with guild IDs as keys
        self.privilegedRolesCache = {}

        # excludedRolesCache dictionary stores sets of IDs of roles that are to be excluded from @everyone operations
        # for bot commands, such as kick all or group create with no role specified to group
        self.excludedRolesCache = {}

        # permOverwriteCache stores a dict hierarchy, with the top level being guild ID keys that map to dicts
        # with channel ID keys that map to dicts with role or member ID as keys that map to lists with 2 int values
        # representing the allow/deny pair of a PermissionOverwrite object corresponding to the specific role/member on the
        # specific channel on the specific server
        self.permOverwriteCache = {}

        # pollCache stores a dictionary with keys being guildIDs and the values being dictionaries that use poll IDs as keys
        # with values being a tuple of the channel ID for the channel the poll was posted in and message IDs for the message used
        # as a poll
        self.pollCache = {}

        #### DICTIONARY ASYNC LOCKS ####
        self.prefixCacheLock = asyncio.Lock()
        self.groupCacheLock = asyncio.Lock()
        self.privilegedCacheLock = asyncio.Lock()
        self.excludedCacheLock = asyncio.Lock()
        self.permCacheLock = asyncio.Lock()
        self.pollCacheLock = asyncio.Lock()

        #### DICTIONARY MODIFIED VARS ####
        self.prefixCacheModified = False
        self.groupCacheModified = False
        self.privilegedCacheModified = False
        self.excludedCacheModified = False
        self.permCacheModified = False
        self.pollCacheModified = False


    #### DICTIONARY EDIT METHODS ####
    # awaitable method for adding new roles to the groupRoles set for a specific server id
    async def addGroupRole(self, guildID: int, roleIDs):
        """Adds roleIDs to set in groupRoles with key guildID. roleIDs can be either a single new entry or list of new entries."""
        # loop through and add roles to the groupRolesCache, making a new entry in the dict
        # if the server doesn't already have one
        async with self.groupCacheLock:
            if (str(guildID) not in self.groupRolesCache.keys()):
                self.groupRolesCache[str(guildID)] = set()

            if (isinstance(roleIDs, int)):
                roleIDs = [roleIDs]
            
            for roleID in roleIDs:
                self.groupRolesCache[str(guildID)].add(roleID)

        self.groupCacheModified = True

    # awaitable method for removing existing roles from the groupRoles set for a specific server id
    async def remGroupRole(self, guildID: int, roleIDs):
        """Removes role given by roleID from the set in groupRoles with key guildID."""
        # if guild doesn't have entry in groupRoles, print an error message to console,
        # if this happens its a code error and not a user error, so it shouldn't be reported to user
        if (str(guildID) not in self.groupRolesCache.keys()):
            print("Error: Provided guildID is not entered in groupRoles dictionary!")
            raise EduBotExceptions.GuildNotInCacheError

        if isinstance(roleIDs, int):
            roleIDs = [roleIDs]
        
        async with self.groupCacheLock:
            for roleID in roleIDs:
                self.groupRolesCache[str(guildID)].discard(roleID)

        self.groupCacheModified = True


    # awaitable method for adding new roles to the privilegedRoles set for a specific server id
    async def addPrivilegedRole(self, guildID: int, roleIDs):
        """Adds roleIDs to set in privilegedRoles with key guildID. roleIDs can be either a single new entry or list of new entries."""
        # loop through and add roles to the privilegedRolesCache, making a new entry in the dict
        # if the server doesn't already have one
        async with self.privilegedCacheLock:
            if (str(guildID) not in self.privilegedRolesCache.keys()):
                self.privilegedRolesCache[str(guildID)] = set()

            if (isinstance(roleIDs, int)):
                roleIDs = [roleIDs]
            
            for roleID in roleIDs:
                self.privilegedRolesCache[str(guildID)].add(roleID)

        self.privilegedCacheModified = True

    # awaitable method for removing existing roles from the privilegedRoles set for a specific server id
    async def remPrivilegedRole(self, guildID: int, roleIDs):
        """Removes role given by roleID from the set in privilegedRoles with key guildID."""
        # if guild doesn't have entry in privilegedRoles, print an error message to console,
        # if this happens its a code error and not a user error, so it shouldn't be reported to user
        if (str(guildID) not in self.privilegedRolesCache.keys()):
            print("Error: Provided guildID is not entered in privilegedRoles dictionary!")
            raise EduBotExceptions.GuildNotInCacheError

        if isinstance(roleIDs, int):
            roleIDs = [roleIDs]
        
        async with self.privilegedCacheLock:
            for roleID in roleIDs:
                self.privilegedRolesCache[str(guildID)].discard(roleID)

        self.privilegedCacheModified = True


    # awaitable method for adding new roles to the excludedRoles set for a specific server id
    async def addExcludedRole(self, guildID: int, roleIDs):
        """Adds roleIDs to set in excludedRoles with key guildID. roleIDs can be either a single new entry or list of new entries."""
        # loop through and add roles to the excludedRolesCache, making a new entry in the dict
        # if the server doesn't already have one
        async with self.excludedCacheLock:
            if (str(guildID) not in self.excludedRolesCache.keys()):
                self.excludedRolesCache[str(guildID)] = set()

            if (isinstance(roleIDs, int)):
                roleIDs = [roleIDs]
            
            for roleID in roleIDs:
                self.excludedRolesCache[str(guildID)].add(roleID)

        self.excludedCacheModified = True

    # awaitable method for removing existing roles from the excludedRoles list for a server
    async def remExcludedRole(self, guildID: int, roleIDs):
        """Removes role given by roleID from the set in excludedRoles with key guildID."""
        # if guild doesn't have entry in excludedRoles, print an error message to console,
        # this shouldn't regularly happen, and the error shouldn't be given to the end user
        if (str(guildID) not in self.excludedRolesCache.keys()):
            print("Error: Provided guildID is not entered in excludedRoles dictionary!")
            raise EduBotExceptions.GuildNotInCacheError

        if isinstance(roleIDs, int):
            roleIDs = [roleIDs]
        
        async with self.excludedCacheLock:
            for roleID in roleIDs:
                self.excludedRolesCache[str(guildID)].discard(roleID)

        self.excludedCacheModified = True


    # awaitable method for adding new permission overwrite to permOverwriteCahce
    async def addPermOverwrite(self, guildID: int, channelID: int, id: int, overwrite: discord.PermissionOverwrite):
        """Adds entry to dict hierarchy corresponding to guildID, channelID, and a role or member ID."""
        # add overwrite to the permOverwriteCache under the given server, channel, and role/member id, making a
        # new entry in the dict under a given key if an entry does not already exist
        async with self.permCacheLock:
            if (str(guildID) not in self.permOverwriteCache.keys()):
                self.permOverwriteCache[str(guildID)] = {}
                self.permOverwriteCache[str(guildID)]["isLocked"] = False

            if (str(channelID) not in self.permOverwriteCache[str(guildID)].keys()):
                self.permOverwriteCache[str(guildID)][str(channelID)] = {}

            permPair = [perm.value for perm in overwrite.pair()]
            self.permOverwriteCache[str(guildID)][str(channelID)][str(id)] = permPair

        self.permCacheModified = True

    # awaitable method for removing permission overwrite from permOverwriteCache
    async def remPermOverwrite(self, guildID: int, channelID: Optional[int] = None, id: Optional[int] = None):
        """Removes entry from dict hierarchy corresponding to guildID, channelID, and a role or member ID.
        If all three given, specific overwrite will be removed from cache; if guild and channel ID given,
        specific channels dict will be removed from guild dict; if only guild given, all keys besides isLocked
        will be removed from server dict.
        """
        # check each level of specificity to see if it was given, and remove the most specific entry given
        async with self.permCacheLock:
            if (channelID is not None):
                if (id is not None):
                    self.permOverwriteCache[str(guildID)][str(channelID)].pop(str(id))
                    self.permCacheModified = True
                    return
                else:
                    self.permOverwriteCache[str(guildID)].pop(str(channelID))
                    self.permCacheModified = True
                    return
            else:
                # remove all keys in guild dict besides the key storing the server lock state
                for key in list(self.permOverwriteCache[str(guildID)].keys()):
                    if (key != "isLocked"):
                        self.permOverwriteCache[str(guildID)].pop(key)
                self.permCacheModified = True

    # awaitable method for retrieving a permission overwrite object from the permission data stored in the cache
    async def getPermOverwrite(self, guildID: int, channelID: int, id: int):
        """Retrieves entry from dict hierarchy corresponding to guildID, channelID, and a role or member ID."""
        permAllowDenyValues = self.permOverwriteCache[str(guildID)][str(channelID)][str(id)]
        return discord.PermissionOverwrite.from_pair(discord.Permissions(permAllowDenyValues[0]), discord.Permissions(permAllowDenyValues[1]))

    # awaitable method for adding a poll to the bot's cache
    async def addPoll(self, guildID: int, message: discord.Message):
        """Takes the guild ID of the server and a message object and stores it in the bot's cache, 
        returning a generated poll ID number.
        """
        # generate poll ID and store it as a key in the dictionary under the guildID 
        # with a tuple as its value
        async with self.pollCacheLock:
            if (str(guildID) not in self.pollCache.keys()):
                self.pollCache[str(guildID)] = {}

            pollID = (message.id * message.channel.id) % 100000
            while (str(pollID).zfill(5) in self.pollCache[str(guildID)].keys()):
                pollID += 1
            pollID = str(pollID).zfill(5)

            self.pollCache[str(guildID)][pollID] = (message.id, message.channel.id)

            self.pollCacheModified = True
        
        return pollID

    # awaitable method for removing a poll from the bot's cache
    async def remPoll(self, guildID: int, pollID: str):
        """Takes the guild ID of the server and a poll ID and deletes the poll with the given ID from the cache."""
        async with self.pollCacheLock:
            if (str(guildID) not in self.pollCache.keys()):
                raise EduBotExceptions.GuildNotInCacheError

            if (pollID not in self.pollCache[str(guildID)].keys()):
                raise EduBotExceptions.PollNotInCacheError(id)

            self.pollCache[str(guildID)].pop(pollID)

            self.pollCacheModified = True

    async def retrievePoll(self, guildID: int, pollID: str) -> discord.Message:
        """Takes the guild ID of the server and a poll ID and retrieves the message corresponding to the poll ID."""
        async with self.pollCacheLock:
            if (str(guildID) not in self.pollCache.keys()):
                raise EduBotExceptions.GuildNotInCacheError

            if (pollID not in self.pollCache[str(guildID)].keys()):
                raise EduBotExceptions.PollNotInCacheError(id)

            messageInfo = self.pollCache[str(guildID)][pollID]
            messageChannel = self.bot.get_channel(messageInfo[1])
            message = await messageChannel.fetch_message(messageInfo[0])
            return message


    #### IMPORT/EXPORT ####
    # converter to pass into json.dump to convert sets into lists for serialization
    def structure_default(self, obj):
        if isinstance(obj, set):
            return list(obj)
        elif isinstance(obj, tuple):
            return list(obj)
        raise TypeError

    async def exportPrefixes(self):
        """Awaitable method that dumps prefix cache to json file"""
        async with self.prefixCacheLock:
            with open("../data/PrefixCache.json", "w") as outfile:
                json.dump(self.prefixCache, outfile, indent=4)

    async def exportGroupRoles(self):
        """Awaitable method that dumps group role cache to json file, converting sets into lists"""
        async with self.groupCacheLock:
            with open("../data/GroupRolesCache.json", "w") as outfile:
                json.dump(self.groupRolesCache, outfile, indent=4, default=self.structure_default)
            self.groupCacheModified = False

    async def exportPrivilegedRoles(self):
        """Awaitable method that dumps privileged role cache to json file, converting sets into lists"""
        async with self.privilegedCacheLock:
            with open("../data/PrivilegedRolesCache.json", "w") as outfile:
                json.dump(self.privilegedRolesCache, outfile, indent=4, default=self.structure_default)
            self.privilegedCacheModified = False

    async def exportExcludedRoles(self):
        """Awaitable method that dumps excluded role cache to json file, converting sets into lists"""
        async with self.excludedCacheLock:
            with open("../data/ExcludedRolesCache.json", "w") as outfile:
                json.dump(self.excludedRolesCache, outfile, indent=4, default=self.structure_default)
            self.excludedCacheModified = False

    async def exportPermOverwrites(self):
        """Awaitable method that dumps permission overwrite cache to json file"""
        async with self.permCacheLock:
            with open("../data/PermOverwriteCahce.json", "w") as outfile:
                json.dump(self.permOverwriteCache, outfile, indent=4)
            self.permCacheModified = False

    async def exportPolls(self):
        """Awaitable method that dumps poll cache to json file"""
        async with self.pollCacheLock:
            with open("../data/PollCache.json", "w") as outfile:
                json.dump(self.pollCache, outfile, indent=4, default=self.structure_default)
            self.permCacheModified = False

    # awaitable method that dumps a json conversion of each cache dictionary to a file 
    # if those dicts have been modified
    @tasks.loop(minutes=10)
    async def exportCacheToJSON(self):
        if (self.prefixCacheModified):
            print("Exporting prefix cache...")
            await self.exportPrefixes()
            print("Done.")
        if (self.groupCacheModified):
            print("Exporting group cache...")
            await self.exportGroupRoles()
            print("Done.")
        if (self.privilegedCacheModified):
            print("Exporting privileged cache...")
            await self.exportPrivilegedRoles()
            print("Done.")
        if (self.excludedCacheModified):
            print("Exporting excluded cache...")
            await self.exportExcludedRoles()
            print("Done.")
        if (self.permCacheModified):
            print("Exporting perm cache...")
            await self.exportPermOverwrites()
            print("Done.")
        if (self.pollCacheModified):
            print("Exporting poll cache...")
            await self.exportPolls()
            print("Done.")

    # method that reads in the json files for each cache
    def importCacheFromJSON(self):
        # try to import each cache from their respective json files
        # prefix cache
        try:
            print("Loading PrefixCache.json...")
            with open("../data/PrefixCache.json", "r") as infile:
                self.prefixCache = json.load(infile)
            print("PrefixCache.json loaded!\n")
        except FileNotFoundError:
            self.prefixCache = {}
            print("Error: No input json file for prefixCache found!\n")
        except json.JSONDecodeError:
            self.prefixCache = {}
            print("Error: json file for prefixCache was not valid format!\n")

        # group roles cache
        try:
            print("Loading GroupRolesCache.json...")
            with open("../data/GroupRolesCache.json", "r") as infile:
                self.groupRolesCache = json.load(infile)
            print("GroupRolesCache.json loaded!\n")
        except FileNotFoundError:
            self.groupRolesCache = {}
            print("Error: No input json file for groupRolesCache found!\n")
        except json.JSONDecodeError:
            self.groupRolesCache = {}
            print("Error: json file for groupRolesCache was not valid format!\n")

        for key in self.groupRolesCache.keys():
            self.groupRolesCache[key] = set(self.groupRolesCache[key])

        # privileged roles cache
        try:
            print("Loading PrivilegedRolesCache.json...")
            with open("../data/PrivilegedRolesCache.json", "r") as infile:
                self.privilegedRolesCache = json.load(infile)
            print("PrivilegedRolesCache.json loaded!\n")
        except FileNotFoundError:
            self.privilegedRolesCache = {}
            print("Error: No input json file for privilegedRolesCache found!\n")
        except json.JSONDecodeError:
            self.privilegedRolesCache = {}
            print("Error: json file for privilegedRolesCache was not valid format!\n")

        for key in self.privilegedRolesCache.keys():
            self.privilegedRolesCache[key] = set(self.privilegedRolesCache[key])

        # excluded roles cache
        try:
            print("Loading ExcludedRolesCache.json...")
            with open("../data/ExcludedRolesCache.json", "r") as infile:
                self.excludedRolesCache = json.load(infile)
            print("ExcludedRolesCache.json loaded!\n")
        except FileNotFoundError:
            self.excludedRolesCache = {}
            print("Error: No input json file for excludedRolesCache found!\n")
        except json.JSONDecodeError:
            self.excludedRolesCache = {}
            print("Error: json file for excludedRolesCache was not valid format!\n")

        for key in self.excludedRolesCache.keys():
            self.excludedRolesCache[key] = set(self.excludedRolesCache[key])

        # permission override cache
        try:
            print("Loading PermOverwriteCache.json...")
            with open("../data/PermOverwriteCahce.json", "r") as infile:
                self.permOverwriteCache = json.load(infile)
            print("PermOverwriteCache.json loaded!\n")
        except FileNotFoundError:
            self.permOverwriteCache = {}
            print("Error: No input json file for permOverwriteCache found!\n")
        except json.JSONDecodeError:
            self.permOverwriteCache = {}
            print("Error: json file for permOverwriteCache was not valid format!\n")

        # poll cache
        try:
            print("Loading PollCache.json...")
            with open("../data/PollCache.json", "r") as infile:
                self.pollCache = json.load(infile)
            print("PollCache.json loaded!\n")
        except FileNotFoundError:
            self.pollCache = {}
            print("Error: No input json file for pollCache found!\n")
        except json.JSONDecodeError:
            self.pollCache = {}
            print("Error: json file for pollCache was not valid format!\n")

        for key1 in self.pollCache.keys():
            for key2 in self.pollCache[key1].keys():
                self.pollCache[key1][key2] = tuple(self.pollCache[key1][key2])